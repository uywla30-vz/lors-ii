from lors.src.ast_nodes import *

class CodeGenerator:
    def __init__(self):
        self.code = []
        self.indent_level = 0

    def generate(self, node: ASTNode) -> str:
        self.visit(node)
        return "\n".join(self.code)

    def emit(self, line: str):
        self.code.append("    " * self.indent_level + line)

    def visit(self, node: ASTNode):
        method_name = f'visit_{type(node).__name__}'
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node: ASTNode):
        raise Exception(f'No visit_{type(node).__name__} method')

    def visit_Program(self, node: Program):
        self.emit("#include <iostream>")
        self.emit("#include <string>")
        self.emit("#include <vector>")
        self.emit("#include <cmath>")
        self.emit("#include <fstream>")
        self.emit("#include <cstdlib>")
        self.emit("#include <cstdio>")
        self.emit("#include <sstream>")
        self.emit("#include <algorithm>")
        self.emit("")
        self.emit("// Generated by Lors Compiler")
        self.emit("// Globals for CLI args")
        self.emit("int global_argc;")
        self.emit("char** global_argv;")
        self.emit("")
        self.emit("struct InquireProxy {")
        self.emit("    template<typename T>")
        self.emit("    operator T() {")
        self.emit("        T val;")
        self.emit("        std::cin >> val;")
        self.emit("        return val;")
        self.emit("    }")
        self.emit("};")
        self.emit("InquireProxy inquire() { return InquireProxy(); }")
        self.emit("")
        self.emit("void file_write(std::string path, std::string content) {")
        self.emit("    std::ofstream f(path);")
        self.emit("    f << content;")
        self.emit("    f.close();")
        self.emit("}")
        self.emit("")
        self.emit("std::string file_read(std::string path) {")
        self.emit("    std::ifstream f(path);")
        self.emit("    std::stringstream buffer;")
        self.emit("    buffer << f.rdbuf();")
        self.emit("    return buffer.str();")
        self.emit("}")
        self.emit("")
        self.emit("void execute_system(std::string cmd) {")
        self.emit("    std::system(cmd.c_str());")
        self.emit("}")
        self.emit("")
        self.emit("// String Library Helpers")
        self.emit("std::string str_reverse_helper(std::string s) {")
        self.emit("    std::string rev = s;")
        self.emit("    std::reverse(rev.begin(), rev.end());")
        self.emit("    return rev;")
        self.emit("}")
        self.emit("std::string str_upper_helper(std::string s) {")
        self.emit("    std::string res = s;")
        self.emit("    for(auto &c : res) c = toupper(c);")
        self.emit("    return res;")
        self.emit("}")
        self.emit("std::string str_lower_helper(std::string s) {")
        self.emit("    std::string res = s;")
        self.emit("    for(auto &c : res) c = tolower(c);")
        self.emit("    return res;")
        self.emit("}")
        self.emit("std::string str_substr_helper(std::string s, long long start, long long len) {")
        self.emit("    if (start < 0 || start >= s.length()) return \"\";")
        self.emit("    return s.substr(start, len);")
        self.emit("}")
        self.emit("")

        for decl in node.declarations:
            self.visit(decl)

    def visit_StructDeclaration(self, node: StructDeclaration):
        self.emit(f"struct {node.name} {{")
        self.indent_level += 1
        for field in node.fields:
            self.visit(field)

        # Add constructor for convenience: Point(x, y)
        if node.fields:
            params = []
            inits = []
            for field in node.fields:
                type_name = self.map_type_node(field.var_type)
                params.append(f"{type_name} _{field.name}")
                inits.append(f"{field.name}(_{field.name})")

            self.emit("")
            self.emit(f"{node.name}() {{}}") # Default constructor
            self.emit(f"{node.name}({', '.join(params)}) : {', '.join(inits)} {{}}")

        self.indent_level -= 1
        self.emit("};")
        self.emit("")

    def visit_VariableDeclaration(self, node: VariableDeclaration):
        cpp_type = self.map_type_node(node.var_type)
        init_val = ""
        if node.initializer:
            init_val = f" = {self.visit_expression(node.initializer)}"
        self.emit(f"{cpp_type} {node.name}{init_val};")

    def visit_FunctionDeclaration(self, node: FunctionDeclaration):
        cpp_ret_type = self.map_type_node(node.return_type)

        name = node.name
        param_str = ""

        if node.name == "genesis":
            name = "main"
            if cpp_ret_type != "int":
                cpp_ret_type = "int"
            # Standard main signature to capture args
            param_str = "int argc, char* argv[]"
            self.emit(f"{cpp_ret_type} {name}({param_str}) {{")
            self.emit("    global_argc = argc;")
            self.emit("    global_argv = argv;")
            # Main always has body
            self.indent_level += 1
            self.visit(node.body)
            self.indent_level -= 1
            self.emit("}")
        else:
            params = []
            for param in node.params:
                params.append(f"{self.map_type_node(param.param_type)} {param.name}")
            param_str = ", ".join(params)

            if node.body is None:
                # Forward declaration / Prototype
                self.emit(f"{cpp_ret_type} {name}({param_str});")
            else:
                self.emit(f"{cpp_ret_type} {name}({param_str}) {{")
                self.indent_level += 1
                self.visit(node.body)
                self.indent_level -= 1
                self.emit("}")
        self.emit("")

    def visit_Block(self, node: Block):
        for stmt in node.statements:
            self.visit(stmt)

    def visit_IfStatement(self, node: IfStatement):
        cond = self.visit_expression(node.condition)
        self.emit(f"if ({cond}) {{")
        self.indent_level += 1
        self.visit(node.then_branch)
        self.indent_level -= 1

        if node.else_branch:
            self.emit("} else {")
            self.indent_level += 1
            self.visit(node.else_branch)
            self.indent_level -= 1

        self.emit("}")

    def visit_WhileStatement(self, node: WhileStatement):
        cond = self.visit_expression(node.condition)
        self.emit(f"while ({cond}) {{")
        self.indent_level += 1
        self.visit(node.body)
        self.indent_level -= 1
        self.emit("}")

    def visit_ReturnStatement(self, node: ReturnStatement):
        if node.value:
            val = self.visit_expression(node.value)
            self.emit(f"return {val};")
        else:
            self.emit("return;")

    def visit_ExpressionStatement(self, node: ExpressionStatement):
        expr_code = self.visit_expression(node.expression)
        self.emit(f"{expr_code};")

    def visit_Assignment(self, node: Assignment):
        val = self.visit_expression(node.value)
        self.emit(f"{node.name} = {val};")

    def visit_ArrayAssignment(self, node: ArrayAssignment):
        index = self.visit_expression(node.index)
        val = self.visit_expression(node.value)
        self.emit(f"{node.name}[{index}] = {val};")

    def visit_MemberAssignment(self, node: MemberAssignment):
        obj = self.visit_expression(node.object)
        val = self.visit_expression(node.value)
        self.emit(f"{obj}.{node.member_name} = {val};")

    def visit_expression(self, node: ASTNode) -> str:
        method_name = f'visit_{type(node).__name__}_expr'
        visitor = getattr(self, method_name, self.generic_visit_expr)
        return visitor(node)

    def generic_visit_expr(self, node: ASTNode):
        if isinstance(node, (BinaryOp, Literal, Identifier, FunctionCall, ArrayLiteral, ArrayAccess, InquireExpression, MemberAccess)):
             if isinstance(node, BinaryOp): return self.visit_BinaryOp_expr(node)
             if isinstance(node, Literal): return self.visit_Literal_expr(node)
             if isinstance(node, Identifier): return self.visit_Identifier_expr(node)
             if isinstance(node, FunctionCall): return self.visit_FunctionCall_expr(node)
             if isinstance(node, ArrayLiteral): return self.visit_ArrayLiteral_expr(node)
             if isinstance(node, ArrayAccess): return self.visit_ArrayAccess_expr(node)
             if isinstance(node, InquireExpression): return self.visit_InquireExpression_expr(node)
             if isinstance(node, MemberAccess): return self.visit_MemberAccess_expr(node)

        raise Exception(f'Unknown expression type {type(node).__name__}')

    def visit_BinaryOp_expr(self, node: BinaryOp) -> str:
        if node.operator == "not":
            right = self.visit_expression(node.right)
            return f"(!{right})"

        if node.operator == "-" and node.left is None:
            right = self.visit_expression(node.right)
            return f"(-{right})"

        left = self.visit_expression(node.left)
        right = self.visit_expression(node.right)

        op = node.operator
        if op == "and": op = "&&"
        if op == "or": op = "||"

        return f"({left} {op} {right})"

    def visit_Literal_expr(self, node: Literal) -> str:
        if node.value_type == 'series':
            return f'"{node.value}"'
        if node.value_type == 'state':
            return 'true' if node.value else 'false'
        return str(node.value)

    def visit_ArrayLiteral_expr(self, node: ArrayLiteral) -> str:
        elements = [self.visit_expression(e) for e in node.elements]
        return f"{{ {', '.join(elements)} }}"

    def visit_ArrayAccess_expr(self, node: ArrayAccess) -> str:
        index = self.visit_expression(node.index)
        return f"{node.array_name}[{index}]"

    def visit_MemberAccess_expr(self, node: MemberAccess) -> str:
        obj = self.visit_expression(node.object)
        return f"{obj}.{node.member_name}"

    def visit_InquireExpression_expr(self, node: InquireExpression) -> str:
        return "inquire()"

    def visit_Identifier_expr(self, node: Identifier) -> str:
        return node.name

    def visit_FunctionCall_expr(self, node: FunctionCall) -> str:
        if node.name == "reveal":
            if not node.arguments:
                return "std::cout << std::endl"
            args_code = " << ".join([self.visit_expression(arg) for arg in node.arguments])
            return f"std::cout << {args_code} << std::endl"

        # System / CLI Intrinsics
        if node.name == "arg_count":
            return "((long long)global_argc)"

        if node.name == "arg_value":
            if len(node.arguments) == 1:
                idx = self.visit_expression(node.arguments[0])
                return f"std::string(global_argv[{idx}])"

        if node.name == "env_get":
            if len(node.arguments) == 1:
                arg = self.visit_expression(node.arguments[0])
                # Ensure we handle string literals vs std::string
                return f"(std::getenv(std::string({arg}).c_str()) ? std::string(std::getenv(std::string({arg}).c_str())) : \"\")"

        # File System Intrinsics
        if node.name == "file_exists":
            if len(node.arguments) == 1:
                path = self.visit_expression(node.arguments[0])
                # Ensure path is std::string before calling c_str().
                return f"std::ifstream(std::string({path}).c_str()).good()"

        if node.name == "file_remove":
            if len(node.arguments) == 1:
                path = self.visit_expression(node.arguments[0])
                return f"((long long)std::remove(std::string({path}).c_str()))"

        # String Intrinsics - Access & Length
        if node.name == "length":
            if len(node.arguments) == 1:
                arg = self.visit_expression(node.arguments[0])
                return f"((long long){arg}.size())"

        if node.name == "char_at":
             if len(node.arguments) == 2:
                 s = self.visit_expression(node.arguments[0])
                 idx = self.visit_expression(node.arguments[1])
                 # Returns char code (whole)
                 return f"((long long){s}[{idx}])"

        if node.name == "substring":
             if len(node.arguments) == 3:
                 s = self.visit_expression(node.arguments[0])
                 start = self.visit_expression(node.arguments[1])
                 length = self.visit_expression(node.arguments[2])
                 return f"str_substr_helper({s}, {start}, {length})"

        # Character Properties
        char_check_map = {
            "is_digit": "isdigit",
            "is_alpha": "isalpha",
            "is_alnum": "isalnum",
            "is_space": "isspace",
            "is_upper": "isupper",
            "is_lower": "islower"
        }
        if node.name in char_check_map:
            if len(node.arguments) == 1:
                arg = self.visit_expression(node.arguments[0])
                # Ensure we call std:: version and cast to unsigned char for safety
                return f"(bool)std::{char_check_map[node.name]}((unsigned char){arg})"

        # Conversion Utils
        if node.name == "to_upper":
             if len(node.arguments) == 1:
                 return f"str_upper_helper({self.visit_expression(node.arguments[0])})"

        if node.name == "to_lower":
             if len(node.arguments) == 1:
                 return f"str_lower_helper({self.visit_expression(node.arguments[0])})"

        if node.name == "reverse":
             if len(node.arguments) == 1:
                 return f"str_reverse_helper({self.visit_expression(node.arguments[0])})"

        if node.name == "to_string":
             if len(node.arguments) == 1:
                 return f"std::to_string({self.visit_expression(node.arguments[0])})"

        if node.name == "to_integer":
             if len(node.arguments) == 1:
                 # stoi returns int, map to long long
                 return f"((long long)std::stoll({self.visit_expression(node.arguments[0])}))"

        if node.name == "to_precise":
             if len(node.arguments) == 1:
                 return f"std::stod({self.visit_expression(node.arguments[0])})"

        if node.name == "ascii":
             if len(node.arguments) == 1:
                 arg = self.visit_expression(node.arguments[0])
                 return f"((long long){arg}[0])"

        if node.name == "character":
             if len(node.arguments) == 1:
                 arg = self.visit_expression(node.arguments[0])
                 return f"std::string(1, (char){arg})"

        if node.name == "exit_program":
             if len(node.arguments) == 1:
                 arg = self.visit_expression(node.arguments[0])
                 # exit() returns void, so we use the comma operator to make this expression valid
                 # but actually since exit terminates, it doesn't matter much.
                 # However, to be safe in expression context: (std::exit(arg), 0)
                 # But wait, std::exit is void.
                 # If we use it as a statement: "exit_program(1);" -> "std::exit(1);".
                 # If we use it as expression: "x = exit_program(1);" -> "x = std::exit(1);" which is invalid.
                 # Since Lors defines it as returning void, it should be used in statement context.
                 # But visit_FunctionCall_expr returns a string that is put into a statement "str;"
                 # So returning "std::exit(...)" is fine.
                 return f"std::exit({arg})"

        if node.name == "append":
             # append(sequence, item)
             if len(node.arguments) == 2:
                 seq = self.visit_expression(node.arguments[0])
                 item = self.visit_expression(node.arguments[1])
                 return f"{seq}.push_back({item})"

        # Math functions mapping
        math_map = {
            "root": "std::sqrt",
            "power": "std::pow",
            "absolute": "std::abs",
            "sine": "std::sin",
            "cosine": "std::cos",
            "tangent": "std::tan"
        }

        fname = math_map.get(node.name, node.name)
        args = [self.visit_expression(arg) for arg in node.arguments]
        return f"{fname}({', '.join(args)})"

    def map_type_node(self, type_node: TypeNode) -> str:
        if type_node.name == "sequence":
             subtype = self.map_type_node(type_node.subtype)
             return f"std::vector<{subtype}>"

        mapping = {
            "whole": "long long",
            "precise": "double",
            "series": "std::string",
            "state": "bool",
            "void": "void"
        }
        # If not a base type, assume it's a struct name
        return mapping.get(type_node.name, type_node.name)
